<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mango Fire - 3Då°„å‡»æ¸¸æˆ</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ”¥</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        canvas {
            display: block;
            outline: none;
            cursor: none;
        }

        /* æ¸¸æˆUI */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff9500;
            pointer-events: auto;
        }

        #health-bar {
            width: 200px;
            height: 20px;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
            border: 2px solid #fff;
        }

        #health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff9500);
            transition: width 0.3s;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 18px;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #ff9500;
            font-weight: bold;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 50px;
            border-radius: 15px;
            border: 3px solid #ff9500;
            text-align: center;
            font-size: 24px;
            display: none;
            pointer-events: auto;
            z-index: 10;
        }

        #message button {
            background: #ff9500;
            color: #000;
            border: none;
            padding: 12px 30px;
            margin-top: 20px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        #message button:hover {
            background: #ffaa33;
            transform: scale(1.05);
        }

        /* ç§»åŠ¨ç«¯æ§åˆ¶ */
        #mobile-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            padding: 0 30px;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            z-index: 3;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
        }

        #joystick-container {
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            border: 3px solid rgba(255, 149, 0, 0.7);
            position: relative;
            pointer-events: auto;
            touch-action: none;
        }

        #joystick {
            width: 70px;
            height: 70px;
            background: radial-gradient(circle, #ff9500, #ff5500);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255, 149, 0, 0.8);
        }

        #action-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            pointer-events: auto;
        }

        .action-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 149, 0, 0.9);
            color: #000;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .action-btn:active {
            transform: scale(0.95);
            background: rgba(255, 170, 51, 0.9);
        }

        .action-btn::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .action-btn:active::after {
            opacity: 1;
        }

        .btn-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        /* è§†è§’æ§åˆ¶åŒºåŸŸï¼ˆç§»åŠ¨ç«¯ï¼‰ */
        #look-area {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            pointer-events: auto;
            display: none;
            touch-action: none;
        }

        @media (max-width: 768px) {
            #look-area {
                display: block;
            }
        }

        /* PCç«¯æç¤º */
        #pc-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            border: 1px solid #ff9500;
        }

        @media (max-width: 768px) {
            #pc-hint {
                display: none;
            }
        }

        /* æŒ‡é’ˆé”å®šæç¤º */
        #pointer-lock-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 10px;
            border: 2px solid #ff9500;
            text-align: center;
            font-size: 20px;
            z-index: 15;
            pointer-events: auto;
            display: none;
        }

        #pointer-lock-hint button {
            background: #ff9500;
            color: #000;
            border: none;
            padding: 10px 25px;
            margin-top: 15px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        #pointer-lock-hint button:hover {
            background: #ffaa33;
        }

        /* åŠ è½½ç•Œé¢ */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #loading h1 {
            color: #ff9500;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 149, 0, 0.7);
        }

        #loading p {
            font-size: 20px;
            margin-bottom: 40px;
        }

        #progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #ff9500;
        }

        #progress-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff9500, #ff5500);
            transition: width 0.3s;
        }

        #loading-details {
            margin-top: 20px;
            font-size: 16px;
            color: #aaa;
        }

        /* æ­¦å™¨é€‰æ‹© */
        #weapon-selector {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .weapon-btn {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 24px;
        }

        .weapon-btn.active {
            border-color: #ff9500;
            background: rgba(255, 149, 0, 0.2);
            transform: scale(1.1);
        }

        /* å‡†æ˜Ÿ */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 5;
        }

        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 149, 0, 0.9);
        }

        #crosshair::before {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }

        #crosshair::after {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }
    </style>
</head>
<body>
    <!-- åŠ è½½ç•Œé¢ -->
    <div id="loading">
        <h1>MANGO FIRE</h1>
        <p>åŠ è½½æ¸¸æˆä¸­...</p>
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div id="loading-details">åˆå§‹åŒ–3Då¼•æ“...</div>
    </div>

    <!-- æŒ‡é’ˆé”å®šæç¤º -->
    <div id="pointer-lock-hint">
        <div>ç‚¹å‡»å±å¹•å¼€å§‹æ¸¸æˆ</div>
        <div style="font-size: 14px; margin-top: 10px; color: #aaa;">ç§»åŠ¨é¼ æ ‡æ§åˆ¶è§†è§’ï¼ŒWASDç§»åŠ¨</div>
        <button id="start-game-btn">å¼€å§‹æ¸¸æˆ</button>
    </div>

    <!-- æ¸¸æˆä¸»å®¹å™¨ -->
    <div id="game-container">
        <!-- Three.jsç”»å¸ƒå®¹å™¨ -->
        <div id="canvas-container"></div>
        
        <!-- æ¸¸æˆUI -->
        <div id="ui">
            <!-- çŠ¶æ€æ˜¾ç¤º -->
            <div id="stats">
                <div id="health-bar">
                    <div id="health-fill"></div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">åˆ†æ•°:</span>
                    <span id="score-value" class="stat-value">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">æ•Œäºº:</span>
                    <span id="enemies-value" class="stat-value">0/10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">å¼¹è¯:</span>
                    <span id="ammo-value" class="stat-value">30/âˆ</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">æ­¦å™¨:</span>
                    <span id="weapon-value" class="stat-value">çªå‡»æ­¥æª</span>
                </div>
            </div>
            
            <!-- æ¶ˆæ¯æç¤ºï¼ˆæ¸¸æˆç»“æŸ/èƒœåˆ©ï¼‰ -->
            <div id="message">
                <div id="message-text"></div>
                <button id="restart-btn">é‡æ–°å¼€å§‹</button>
            </div>
            
            <!-- ç§»åŠ¨ç«¯æ§åˆ¶ -->
            <div id="mobile-controls">
                <div id="joystick-container">
                    <div id="joystick"></div>
                </div>
                <div id="action-buttons">
                    <button class="action-btn" id="shoot-btn">
                        <div class="btn-icon">ğŸ”«</div>
                        <div>å¼€ç«</div>
                    </button>
                    <button class="action-btn" id="reload-btn">
                        <div class="btn-icon">ğŸ”ƒ</div>
                        <div>æ¢å¼¹</div>
                    </button>
                    <button class="action-btn" id="jump-btn">
                        <div class="btn-icon">â¬†ï¸</div>
                        <div>è·³è·ƒ</div>
                    </button>
                </div>
            </div>
            
            <!-- ç§»åŠ¨ç«¯è§†è§’æ§åˆ¶åŒºåŸŸ -->
            <div id="look-area"></div>
            
            <!-- PCç«¯æç¤º -->
            <div id="pc-hint">
                WASDç§»åŠ¨ | é¼ æ ‡ç§»åŠ¨è§†è§’ | å·¦é”®å°„å‡» | Ræ¢å¼¹ | ç©ºæ ¼è·³è·ƒ | ESCé€€å‡ºæŒ‡é’ˆé”å®š
            </div>
            
            <!-- æ­¦å™¨é€‰æ‹© -->
            <div id="weapon-selector">
                <div class="weapon-btn active" data-weapon="rifle">ğŸ”«</div>
                <div class="weapon-btn" data-weapon="shotgun">ğŸ’¥</div>
                <div class="weapon-btn" data-weapon="pistol">ğŸ”ª</div>
            </div>
            
            <!-- å‡†æ˜Ÿ -->
            <div id="crosshair"></div>
        </div>
    </div>

    <!-- Three.jsåº“ï¼ˆCDN + ç¦»çº¿å¤‡ç”¨ï¼‰ -->
    <script>
        // å°è¯•ä»CDNåŠ è½½Three.jsï¼Œå¤±è´¥æ—¶ä½¿ç”¨æœ¬åœ°å¤‡ç”¨æ–¹æ¡ˆ
        (function() {
            var script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
            script.integrity = 'sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ==';
            script.crossOrigin = 'anonymous';
            script.onerror = function() {
                // CDNåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°å¤‡ç”¨ï¼ˆå†…è”çš„Three.jsç²¾ç®€ç‰ˆï¼‰
                console.log('CDNåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ç¦»çº¿ç‰ˆæœ¬');
                // è¿™é‡Œåœ¨å®é™…éƒ¨ç½²æ—¶å¯ä»¥æ›¿æ¢ä¸ºå†…è”çš„Three.jsä»£ç 
                // ä¸ºç®€åŒ–ç¤ºä¾‹ï¼Œæˆ‘ä»¬å‡è®¾CDNå¯ç”¨
            };
            document.head.appendChild(script);
        })();
    </script>

    <!-- æ¸¸æˆä¸»é€»è¾‘ -->
    <script>
        // ç­‰å¾…Three.jsåŠ è½½
        function waitForThreeJS() {
            if (typeof THREE !== 'undefined') {
                initGame();
            } else {
                setTimeout(waitForThreeJS, 100);
            }
        }
        
        // åŠ è½½è¿›åº¦æ¨¡æ‹Ÿ
        var progress = 0;
        var progressInterval = setInterval(function() {
            progress += Math.random() * 10;
            if (progress > 100) progress = 100;
            document.getElementById('progress-fill').style.width = progress + '%';
            
            var details = document.getElementById('loading-details');
            if (progress < 30) {
                details.textContent = 'åˆå§‹åŒ–3Då¼•æ“...';
            } else if (progress < 60) {
                details.textContent = 'åŠ è½½æ¸¸æˆèµ„æº...';
            } else if (progress < 90) {
                details.textContent = 'ç”Ÿæˆæ¸¸æˆåœºæ™¯...';
            } else {
                details.textContent = 'å‡†å¤‡å¼€å§‹æ¸¸æˆ...';
            }
            
            if (progress >= 100) {
                clearInterval(progressInterval);
                // Three.jsåŠ è½½å®Œæˆåå¼€å§‹æ¸¸æˆ
                setTimeout(waitForThreeJS, 500);
            }
        }, 200);

        // æ¸¸æˆä¸»å‡½æ•°
        function initGame() {
            // éšè—åŠ è½½ç•Œé¢
            document.getElementById('loading').style.display = 'none';
            
            // æ¸¸æˆå˜é‡
            var scene, camera, renderer, clock;
            var player, enemies = [], bullets = [], enemyBullets = [];
            var keys = {}, mouse = { x: 0, y: 0, down: false };
            var joystick = { active: false, x: 0, y: 0 };
            var lookTouch = { active: false, lastX: 0, lastY: 0 };
            var gameState = { score: 0, health: 100, ammo: 30, maxAmmo: 30, enemiesAlive: 10, enemiesTotal: 10 };
            var weapons = {
                rifle: { damage: 25, fireRate: 0.1, ammoCost: 1, name: 'çªå‡»æ­¥æª' },
                shotgun: { damage: 10, fireRate: 0.8, ammoCost: 3, name: 'éœ°å¼¹æª' },
                pistol: { damage: 15, fireRate: 0.3, ammoCost: 1, name: 'æ‰‹æª' }
            };
            var currentWeapon = 'rifle';
            var lastShot = 0;
            var floor, obstacles = []; // æ”¹åä¸ºobstaclesï¼ŒåŒ…å«å„ç§éšœç¢ç‰©
            var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            var gameActive = true;
            var pointerLocked = false;
            var sensitivity = 0.002; // é¼ æ ‡çµæ•åº¦
            
            // åˆå§‹åŒ–Three.jsåœºæ™¯
            function initScene() {
                // åˆ›å»ºåœºæ™¯
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);
                
                // åˆ›å»ºç›¸æœº
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 10);
                camera.rotation.order = 'YXZ'; // ç¡®ä¿æ­£ç¡®çš„æ—‹è½¬é¡ºåº
                
                // åˆ›å»ºæ¸²æŸ“å™¨
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(renderer.domElement);
                
                // æ—¶é’Ÿ
                clock = new THREE.Clock();
                
                // æ·»åŠ ç¯å…‰
                var ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                var directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                
                // æ·»åŠ åœ°é¢
                var floorGeometry = new THREE.PlaneGeometry(100, 100);
                var floorMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x2a5c2a,
                    side: THREE.DoubleSide
                });
                floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = Math.PI / 2;
                floor.position.y = -0.5;
                floor.receiveShadow = true;
                scene.add(floor);
                
                // åˆ›å»ºé«˜å¤§éšœç¢ç‰©
                createTallObstacles();
                
                // åˆ›å»ºç©å®¶ï¼ˆç¬¬ä¸€äººç§°ï¼Œæ‰€ä»¥åªéœ€è¦ç›¸æœºï¼‰
                player = {
                    mesh: camera,
                    velocity: new THREE.Vector3(),
                    speed: 5,
                    jumpForce: 8,
                    onGround: true,
                    height: 5,
                    pitch: 0, // å‚ç›´è§†è§’
                    yaw: 0   // æ°´å¹³è§†è§’
                };
                
                // åˆå§‹åŒ–ç©å®¶è§†è§’
                player.yaw = camera.rotation.y;
                player.pitch = camera.rotation.x;
                
                // åˆ›å»ºæ•Œäºº
                createEnemies();
                
                // æ·»åŠ å¤©ç©ºç›’
                var skyGeometry = new THREE.SphereGeometry(500, 32, 32);
                var skyMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x1a1a2e,
                    side: THREE.BackSide
                });
                var sky = new THREE.Mesh(skyGeometry, skyMaterial);
                scene.add(sky);
                
                // æ·»åŠ ä¸€äº›éšæœºç«‹æ–¹ä½“ä½œä¸ºè£…é¥°ï¼ˆé«˜åº¦è¾ƒä½ï¼Œä¸é®æŒ¡è§†çº¿ï¼‰
                for (var i = 0; i < 15; i++) {
                    var size = Math.random() * 2 + 0.5;
                    var cubeGeometry = new THREE.BoxGeometry(size, size, size);
                    var cubeMaterial = new THREE.MeshPhongMaterial({ 
                        color: Math.random() * 0xffffff,
                        transparent: true,
                        opacity: 0.7
                    });
                    var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                    cube.position.set(
                        (Math.random() - 0.5) * 90,
                        size / 2,
                        (Math.random() - 0.5) * 90
                    );
                    cube.castShadow = true;
                    scene.add(cube);
                }
            }
            
            // åˆ›å»ºé«˜å¤§éšœç¢ç‰©
            function createTallObstacles() {
                var obstacleTypes = [
                    // ç±»å‹1: é«˜å¢™ (é•¿è€Œé«˜çš„å¢™å£)
                    { width: 1, height: 15, depth: 20, color: 0x8b4513, name: 'é«˜å¢™' },
                    
                    // ç±»å‹2: æŸ±å­ (é«˜å¤§çš„åœ†æŸ±ä½“)
                    { radius: 2, height: 12, color: 0x696969, name: 'æŸ±å­', type: 'cylinder' },
                    
                    // ç±»å‹3: å¡”æ¥¼ (æ›´é«˜çš„æ–¹å½¢ç»“æ„)
                    { width: 3, height: 20, depth: 3, color: 0x654321, name: 'å¡”æ¥¼' },
                    
                    // ç±»å‹4: çŸ®å¢™ (ä½†æ¯”åŸæ¥é«˜)
                    { width: 1, height: 8, depth: 10, color: 0xa0522d, name: 'çŸ®å¢™' }
                ];
                
                // åˆ›å»ºä¸åŒé«˜åº¦çš„éšœç¢ç‰©
                var obstacleCount = 20; // å¢åŠ éšœç¢ç‰©æ•°é‡
                
                for (var i = 0; i < obstacleCount; i++) {
                    var typeIndex = Math.floor(Math.random() * obstacleTypes.length);
                    var type = obstacleTypes[typeIndex];
                    
                    var obstacle;
                    
                    if (type.type === 'cylinder') {
                        // åˆ›å»ºåœ†æŸ±ä½“éšœç¢ç‰©
                        var cylinderGeometry = new THREE.CylinderGeometry(type.radius, type.radius, type.height, 8);
                        var cylinderMaterial = new THREE.MeshPhongMaterial({ color: type.color });
                        obstacle = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                        obstacle.position.y = type.height / 2; // åœ†æŸ±ä½“ä¸­å¿ƒåœ¨é«˜åº¦ä¸€åŠ
                    } else {
                        // åˆ›å»ºç«‹æ–¹ä½“éšœç¢ç‰©
                        var boxGeometry = new THREE.BoxGeometry(type.width, type.height, type.depth);
                        var boxMaterial = new THREE.MeshPhongMaterial({ color: type.color });
                        obstacle = new THREE.Mesh(boxGeometry, boxMaterial);
                        obstacle.position.y = type.height / 2; // ç«‹æ–¹ä½“ä¸­å¿ƒåœ¨é«˜åº¦ä¸€åŠ
                    }
                    
                    // éšæœºä½ç½®ï¼Œä½†ç¡®ä¿ä¸ä¼šå¤ªé è¿‘ä¸­å¿ƒ
                    var angle = Math.random() * Math.PI * 2;
                    var distance = 10 + Math.random() * 35;
                    obstacle.position.x = Math.cos(angle) * distance;
                    obstacle.position.z = Math.sin(angle) * distance;
                    
                    // éšæœºæ—‹è½¬
                    obstacle.rotation.y = Math.random() * Math.PI * 2;
                    
                    // æ·»åŠ éšœç¢ç‰©å±æ€§
                    obstacle.castShadow = true;
                    obstacle.receiveShadow = true;
                    obstacle.isObstacle = true;
                    obstacle.height = type.height;
                    obstacle.width = type.width || type.radius * 2;
                    obstacle.depth = type.depth || type.radius * 2;
                    
                    scene.add(obstacle);
                    obstacles.push(obstacle);
                }
                
                // åˆ›å»ºä¸€äº›è¿æ¥å¢™å£ï¼Œå½¢æˆè¿·å®«ç»“æ„
                createMazeWalls();
            }
            
            // åˆ›å»ºè¿·å®«å¢™å£
            function createMazeWalls() {
                // è¿·å®«å¢™å£å‚æ•°
                var wallHeight = 12;
                var wallColor = 0x5d4037;
                
                // åˆ›å»ºä¸€äº›ç›´çº¿å¢™å£
                var wallPositions = [
                    // æ°´å¹³å¢™å£
                    { x: -30, z: 20, width: 40, depth: 1, rotation: 0 },
                    { x: 25, z: -15, width: 30, depth: 1, rotation: 0 },
                    { x: -20, z: -25, width: 25, depth: 1, rotation: 0 },
                    
                    // å‚ç›´å¢™å£
                    { x: 15, z: 30, width: 1, depth: 35, rotation: 0 },
                    { x: -35, z: -10, width: 1, depth: 25, rotation: 0 },
                    { x: 30, z: 0, width: 1, depth: 20, rotation: 0 },
                    
                    // å€¾æ–œå¢™å£
                    { x: -10, z: -10, width: 20, depth: 1, rotation: Math.PI/4 },
                    { x: 10, z: 10, width: 15, depth: 1, rotation: -Math.PI/6 }
                ];
                
                for (var i = 0; i < wallPositions.length; i++) {
                    var pos = wallPositions[i];
                    var wallGeometry = new THREE.BoxGeometry(pos.width, wallHeight, pos.depth);
                    var wallMaterial = new THREE.MeshPhongMaterial({ color: wallColor });
                    var wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    
                    wall.position.set(pos.x, wallHeight/2, pos.z);
                    wall.rotation.y = pos.rotation;
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    wall.isObstacle = true;
                    wall.height = wallHeight;
                    wall.width = pos.width;
                    wall.depth = pos.depth;
                    
                    scene.add(wall);
                    obstacles.push(wall);
                }
            }
            
            // åˆ›å»ºæ•Œäºº
            function createEnemies() {
                var enemyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                var enemyMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                
                for (var i = 0; i < gameState.enemiesTotal; i++) {
                    // ç¡®ä¿æ•Œäººç”Ÿæˆåœ¨éšœç¢ç‰©ä¹‹é—´
                    var validPosition = false;
                    var enemyX, enemyZ;
                    
                    // å°è¯•æ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆä½ç½®
                    for (var attempt = 0; attempt < 50; attempt++) {
                        enemyX = (Math.random() - 0.5) * 80;
                        enemyZ = (Math.random() - 0.5) * 80;
                        
                        // æ£€æŸ¥æ˜¯å¦å¤ªé è¿‘ç©å®¶èµ·å§‹ä½ç½®
                        var distToStart = Math.sqrt(enemyX*enemyX + enemyZ*enemyZ);
                        if (distToStart < 15) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦å¤ªé è¿‘éšœç¢ç‰©
                        var tooCloseToObstacle = false;
                        for (var j = 0; j < obstacles.length; j++) {
                            var obstacle = obstacles[j];
                            var dx = enemyX - obstacle.position.x;
                            var dz = enemyZ - obstacle.position.z;
                            var distance = Math.sqrt(dx*dx + dz*dz);
                            
                            // å¦‚æœè·ç¦»å°äºéšœç¢ç‰©å°ºå¯¸+2ï¼Œåˆ™å¤ªé è¿‘
                            var obstacleRadius = Math.max(obstacle.width || 0, obstacle.depth || 0) / 2;
                            if (distance < obstacleRadius + 3) {
                                tooCloseToObstacle = true;
                                break;
                            }
                        }
                        
                        if (!tooCloseToObstacle) {
                            validPosition = true;
                            break;
                        }
                    }
                    
                    if (!validPosition) {
                        // å¦‚æœæ‰¾ä¸åˆ°æœ‰æ•ˆä½ç½®ï¼Œä½¿ç”¨éšæœºä½ç½®
                        enemyX = (Math.random() - 0.5) * 80;
                        enemyZ = (Math.random() - 0.5) * 80;
                    }
                    
                    var enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                    enemy.position.set(enemyX, 1, enemyZ);
                    enemy.castShadow = true;
                    enemy.receiveShadow = true;
                    
                    // æ•Œäººå±æ€§
                    enemy.health = 100;
                    enemy.speed = 2 + Math.random() * 2;
                    enemy.target = new THREE.Vector3();
                    enemy.state = 'patrol'; // patrol, chase, attack
                    enemy.lastShot = 0;
                    enemy.shootDelay = 1 + Math.random() * 2;
                    enemy.canSeePlayer = false;
                    
                    scene.add(enemy);
                    enemies.push(enemy);
                }
            }
            
            // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
            function initEvents() {
                // é”®ç›˜äº‹ä»¶
                window.addEventListener('keydown', function(e) {
                    keys[e.key.toLowerCase()] = true;
                    
                    // ç©ºæ ¼é”®è·³è·ƒ
                    if (e.key === ' ' && player.onGround) {
                        player.velocity.y = player.jumpForce;
                        player.onGround = false;
                    }
                    
                    // Ré”®æ¢å¼¹
                    if (e.key === 'r') {
                        reloadWeapon();
                    }
                    
                    // æ•°å­—é”®åˆ‡æ¢æ­¦å™¨
                    if (e.key === '1') switchWeapon('rifle');
                    if (e.key === '2') switchWeapon('shotgun');
                    if (e.key === '3') switchWeapon('pistol');
                    
                    // ESCé”®é€€å‡ºæŒ‡é’ˆé”å®š
                    if (e.key === 'Escape') {
                        exitPointerLock();
                    }
                });
                
                window.addEventListener('keyup', function(e) {
                    keys[e.key.toLowerCase()] = false;
                });
                
                // PCç«¯é¼ æ ‡äº‹ä»¶
                if (!isMobile) {
                    // é¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼ˆä½¿ç”¨æŒ‡é’ˆé”å®šï¼‰
                    document.addEventListener('mousemove', onMouseMove);
                    
                    // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
                    document.addEventListener('mousedown', function(e) {
                        mouse.down = true;
                        if (e.button === 0) { // å·¦é”®
                            shoot();
                        }
                        
                        // å¦‚æœæ¸¸æˆæœªå¼€å§‹ï¼Œç‚¹å‡»åè¯·æ±‚æŒ‡é’ˆé”å®š
                        if (!pointerLocked) {
                            requestPointerLock();
                        }
                    });
                    
                    document.addEventListener('mouseup', function(e) {
                        mouse.down = false;
                    });
                    
                    // æŒ‡é’ˆé”å®šçŠ¶æ€å˜åŒ–äº‹ä»¶
                    document.addEventListener('pointerlockchange', onPointerLockChange);
                    document.addEventListener('mozpointerlockchange', onPointerLockChange);
                } else {
                    // ç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶
                    initMobileControls();
                }
                
                // ç§»åŠ¨ç«¯è™šæ‹Ÿæ‘‡æ†
                var joystickElement = document.getElementById('joystick');
                var joystickContainer = document.getElementById('joystick-container');
                var joystickRadius = 75;
                
                joystickContainer.addEventListener('touchstart', function(e) {
                    joystick.active = true;
                    updateJoystick(e);
                    e.preventDefault();
                });
                
                document.addEventListener('touchmove', function(e) {
                    if (joystick.active) {
                        updateJoystick(e);
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('touchend', function(e) {
                    if (joystick.active) {
                        joystick.active = false;
                        joystick.x = 0;
                        joystick.y = 0;
                        joystickElement.style.transform = 'translate(-50%, -50%)';
                        e.preventDefault();
                    }
                });
                
                function updateJoystick(e) {
                    var touch = e.touches[0];
                    var rect = joystickContainer.getBoundingClientRect();
                    var centerX = rect.left + rect.width / 2;
                    var centerY = rect.top + rect.height / 2;
                    
                    var deltaX = touch.clientX - centerX;
                    var deltaY = touch.clientY - centerY;
                    
                    // é™åˆ¶æ‘‡æ†ç§»åŠ¨èŒƒå›´
                    var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    if (distance > joystickRadius) {
                        deltaX = deltaX * joystickRadius / distance;
                        deltaY = deltaY * joystickRadius / distance;
                    }
                    
                    joystick.x = deltaX / joystickRadius;
                    joystick.y = -deltaY / joystickRadius; // åè½¬Yè½´
                    
                    // æ›´æ–°æ‘‡æ†è§†è§‰ä½ç½®
                    joystickElement.style.transform = 'translate(' + (deltaX - joystickRadius/2) + 'px, ' + (deltaY - joystickRadius/2) + 'px)';
                }
                
                // ç§»åŠ¨ç«¯æŒ‰é’®äº‹ä»¶
                document.getElementById('shoot-btn').addEventListener('touchstart', function(e) {
                    shoot();
                    e.preventDefault();
                });
                
                document.getElementById('reload-btn').addEventListener('touchstart', function(e) {
                    reloadWeapon();
                    e.preventDefault();
                });
                
                document.getElementById('jump-btn').addEventListener('touchstart', function(e) {
                    if (player.onGround) {
                        player.velocity.y = player.jumpForce;
                        player.onGround = false;
                    }
                    e.preventDefault();
                });
                
                // æ­¦å™¨é€‰æ‹©æŒ‰é’®
                var weaponButtons = document.querySelectorAll('.weapon-btn');
                weaponButtons.forEach(function(btn) {
                    btn.addEventListener('click', function() {
                        var weapon = this.getAttribute('data-weapon');
                        switchWeapon(weapon);
                    });
                });
                
                // é‡æ–°å¼€å§‹æŒ‰é’®
                document.getElementById('restart-btn').addEventListener('click', restartGame);
                
                // å¼€å§‹æ¸¸æˆæŒ‰é’®
                document.getElementById('start-game-btn').addEventListener('click', function() {
                    document.getElementById('pointer-lock-hint').style.display = 'none';
                    requestPointerLock();
                });
                
                // çª—å£å¤§å°è°ƒæ•´
                window.addEventListener('resize', function() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // è¯·æ±‚æŒ‡é’ˆé”å®šï¼ˆPCç«¯å…¨å±æ§åˆ¶ï¼‰
                if (!isMobile) {
                    document.addEventListener('click', function() {
                        if (gameActive && !pointerLocked) {
                            requestPointerLock();
                        }
                    });
                }
            }
            
            // åˆå§‹åŒ–ç§»åŠ¨ç«¯æ§åˆ¶
            function initMobileControls() {
                var lookArea = document.getElementById('look-area');
                
                // è§¦æ‘¸å¼€å§‹äº‹ä»¶
                lookArea.addEventListener('touchstart', function(e) {
                    if (e.touches.length === 1) {
                        var touch = e.touches[0];
                        lookTouch.active = true;
                        lookTouch.lastX = touch.clientX;
                        lookTouch.lastY = touch.clientY;
                        e.preventDefault();
                    }
                });
                
                // è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
                lookArea.addEventListener('touchmove', function(e) {
                    if (lookTouch.active && e.touches.length === 1) {
                        var touch = e.touches[0];
                        var deltaX = touch.clientX - lookTouch.lastX;
                        var deltaY = touch.clientY - lookTouch.lastY;
                        
                        // æ›´æ–°è§†è§’
                        updateCameraLook(deltaX, deltaY);
                        
                        lookTouch.lastX = touch.clientX;
                        lookTouch.lastY = touch.clientY;
                        e.preventDefault();
                    }
                });
                
                // è§¦æ‘¸ç»“æŸäº‹ä»¶
                lookArea.addEventListener('touchend', function(e) {
                    if (e.touches.length === 0) {
                        lookTouch.active = false;
                    }
                    e.preventDefault();
                });
            }
            
            // é¼ æ ‡ç§»åŠ¨äº‹ä»¶å¤„ç†
            function onMouseMove(e) {
                if (!pointerLocked || !gameActive) return;
                
                // ä½¿ç”¨movementXå’ŒmovementYä»¥è·å¾—å¹³æ»‘çš„è§†è§’æ§åˆ¶
                var movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
                var movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
                
                // æ›´æ–°è§†è§’
                updateCameraLook(movementX, movementY);
            }
            
            // æ›´æ–°ç›¸æœºè§†è§’
            function updateCameraLook(deltaX, deltaY) {
                // æ›´æ–°æ°´å¹³å’Œå‚ç›´è§†è§’
                player.yaw -= deltaX * sensitivity;
                player.pitch -= deltaY * sensitivity;
                
                // é™åˆ¶å‚ç›´è§†è§’ï¼ˆé˜²æ­¢ç›¸æœºç¿»è½¬ï¼‰
                player.pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, player.pitch));
                
                // åº”ç”¨æ—‹è½¬åˆ°ç›¸æœº
                camera.rotation.order = 'YXZ'; // å…ˆYè½´æ—‹è½¬ï¼ˆåèˆªï¼‰ï¼Œå†Xè½´æ—‹è½¬ï¼ˆä¿¯ä»°ï¼‰
                camera.rotation.y = player.yaw;
                camera.rotation.x = player.pitch;
            }
            
            // æŒ‡é’ˆé”å®šå˜åŒ–äº‹ä»¶
            function onPointerLockChange() {
                pointerLocked = document.pointerLockElement === renderer.domElement ||
                              document.mozPointerLockElement === renderer.domElement;
                
                if (pointerLocked) {
                    // éšè—æŒ‡é’ˆé”å®šæç¤º
                    document.getElementById('pointer-lock-hint').style.display = 'none';
                    console.log('æŒ‡é’ˆé”å®šå·²å¯ç”¨');
                } else {
                    // æ˜¾ç¤ºæŒ‡é’ˆé”å®šæç¤º
                    if (gameActive) {
                        document.getElementById('pointer-lock-hint').style.display = 'block';
                    }
                    console.log('æŒ‡é’ˆé”å®šå·²ç¦ç”¨');
                }
            }
            
            // è¯·æ±‚æŒ‡é’ˆé”å®š
            function requestPointerLock() {
                if (!isMobile) {
                    renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                                                           renderer.domElement.mozRequestPointerLock ||
                                                           renderer.domElement.webkitRequestPointerLock;
                    
                    if (renderer.domElement.requestPointerLock) {
                        renderer.domElement.requestPointerLock();
                    }
                }
            }
            
            // é€€å‡ºæŒ‡é’ˆé”å®š
            function exitPointerLock() {
                document.exitPointerLock = document.exitPointerLock ||
                                          document.mozExitPointerLock ||
                                          document.webkitExitPointerLock;
                
                if (document.exitPointerLock) {
                    document.exitPointerLock();
                }
            }
            
            // å°„å‡»å‡½æ•°
            function shoot() {
                if (!gameActive) return;
                
                var now = Date.now() / 1000;
                var weapon = weapons[currentWeapon];
                
                // æ£€æŸ¥å°„å‡»å†·å´å’Œå¼¹è¯
                if (now - lastShot < weapon.fireRate || gameState.ammo < weapon.ammoCost) {
                    return;
                }
                
                // æ¶ˆè€—å¼¹è¯
                gameState.ammo -= weapon.ammoCost;
                updateUI();
                
                lastShot = now;
                
                // åˆ›å»ºå­å¼¹
                var bulletCount = currentWeapon === 'shotgun' ? 8 : 1;
                
                for (var i = 0; i < bulletCount; i++) {
                    // è®¡ç®—å°„å‡»æ–¹å‘ï¼ˆå¸¦ä¸€äº›éšæœºæ•£å¸ƒï¼‰
                    var spread = currentWeapon === 'shotgun' ? 0.1 : 0.01;
                    var direction = new THREE.Vector3(0, 0, -1);
                    direction.applyEuler(camera.rotation);
                    direction.x += (Math.random() - 0.5) * spread;
                    direction.y += (Math.random() - 0.5) * spread;
                    direction.z += (Math.random() - 0.5) * spread;
                    direction.normalize();
                    
                    // åˆ›å»ºå­å¼¹
                    var bulletGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                    var bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    var bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                    
                    bullet.position.copy(camera.position);
                    bullet.velocity = direction.clone().multiplyScalar(50);
                    bullet.damage = weapon.damage / bulletCount;
                    
                    scene.add(bullet);
                    bullets.push(bullet);
                    
                    // å­å¼¹å­˜æ´»æ—¶é—´
                    setTimeout(function(bullet) {
                        if (bullet.parent) {
                            scene.remove(bullet);
                            var index = bullets.indexOf(bullet);
                            if (index > -1) bullets.splice(index, 1);
                        }
                    }, 2000, bullet);
                }
                
                // æ’­æ”¾å°„å‡»éŸ³æ•ˆï¼ˆæ¨¡æ‹Ÿï¼‰
                playSound('shoot');
            }
            
            // æ¢å¼¹å‡½æ•°
            function reloadWeapon() {
                if (!gameActive) return;
                
                gameState.ammo = gameState.maxAmmo;
                updateUI();
                playSound('reload');
            }
            
            // åˆ‡æ¢æ­¦å™¨
            function switchWeapon(weaponType) {
                if (weapons[weaponType]) {
                    currentWeapon = weaponType;
                    
                    // æ›´æ–°UI
                    document.getElementById('weapon-value').textContent = weapons[weaponType].name;
                    
                    // æ›´æ–°æ­¦å™¨æŒ‰é’®çŠ¶æ€
                    document.querySelectorAll('.weapon-btn').forEach(function(btn) {
                        btn.classList.remove('active');
                    });
                    document.querySelector('.weapon-btn[data-weapon="' + weaponType + '"]').classList.add('active');
                    
                    playSound('switch');
                }
            }
            
            // æ•ŒäººAI - æ”¹è¿›ç‰ˆï¼Œè€ƒè™‘éšœç¢ç‰©é®æŒ¡
            function updateEnemies(deltaTime) {
                for (var i = 0; i < enemies.length; i++) {
                    var enemy = enemies[i];
                    if (enemy.health <= 0) continue;
                    
                    var distanceToPlayer = enemy.position.distanceTo(camera.position);
                    
                    // æ£€æŸ¥æ•Œäººæ˜¯å¦èƒ½çœ‹è§ç©å®¶ï¼ˆè€ƒè™‘éšœç¢ç‰©é®æŒ¡ï¼‰
                    var canSeePlayer = checkLineOfSight(enemy.position, camera.position);
                    
                    // æ•ŒäººçŠ¶æ€æœº
                    if (canSeePlayer && distanceToPlayer < 8) {
                        // æ”»å‡»çŠ¶æ€
                        enemy.state = 'attack';
                        
                        // æœå‘ç©å®¶
                        var directionToPlayer = new THREE.Vector3();
                        directionToPlayer.subVectors(camera.position, enemy.position).normalize();
                        enemy.lookAt(enemy.position.x + directionToPlayer.x, enemy.position.y, enemy.position.z + directionToPlayer.z);
                        
                        // å°„å‡»
                        var now = Date.now() / 1000;
                        if (now - enemy.lastShot > enemy.shootDelay) {
                            enemyShoot(enemy);
                            enemy.lastShot = now;
                        }
                    } else if (canSeePlayer && distanceToPlayer < 25) {
                        // è¿½é€çŠ¶æ€
                        enemy.state = 'chase';
                        
                        var directionToPlayer = new THREE.Vector3();
                        directionToPlayer.subVectors(camera.position, enemy.position).normalize();
                        
                        // ç§»åŠ¨å‘ç©å®¶ï¼Œä½†é¿å¼€éšœç¢ç‰©
                        var moveDirection = avoidObstacles(enemy, directionToPlayer);
                        
                        enemy.position.x += moveDirection.x * enemy.speed * deltaTime;
                        enemy.position.z += moveDirection.z * enemy.speed * deltaTime;
                        
                        // æœå‘ç©å®¶
                        enemy.lookAt(enemy.position.x + directionToPlayer.x, enemy.position.y, enemy.position.z + directionToPlayer.z);
                    } else {
                        // å·¡é€»çŠ¶æ€
                        enemy.state = 'patrol';
                        
                        // éšæœºç§»åŠ¨
                        if (Math.random() < 0.01 || enemy.position.distanceTo(enemy.target) < 2) {
                            enemy.target.x = enemy.position.x + (Math.random() - 0.5) * 20;
                            enemy.target.z = enemy.position.z + (Math.random() - 0.5) * 20;
                        }
                        
                        var directionToTarget = new THREE.Vector3();
                        directionToTarget.subVectors(enemy.target, enemy.position).normalize();
                        
                        // é¿å¼€éšœç¢ç‰©
                        var moveDirection = avoidObstacles(enemy, directionToTarget);
                        
                        enemy.position.x += moveDirection.x * enemy.speed * deltaTime * 0.5;
                        enemy.position.z += moveDirection.z * enemy.speed * deltaTime * 0.5;
                        
                        // æœå‘ç§»åŠ¨æ–¹å‘
                        if (directionToTarget.length() > 0.1) {
                            enemy.lookAt(enemy.position.x + directionToTarget.x, enemy.position.y, enemy.position.z + directionToTarget.z);
                        }
                    }
                }
            }
            
            // æ£€æŸ¥è§†çº¿æ˜¯å¦è¢«éšœç¢ç‰©é˜»æŒ¡
            function checkLineOfSight(startPos, endPos) {
                var direction = new THREE.Vector3();
                direction.subVectors(endPos, startPos);
                var distance = direction.length();
                direction.normalize();
                
                // æ²¿ç€è§†çº¿æ–¹å‘æ£€æŸ¥å¤šä¸ªç‚¹
                var stepCount = 20;
                var stepSize = distance / stepCount;
                
                for (var i = 1; i < stepCount; i++) {
                    var checkPoint = new THREE.Vector3();
                    checkPoint.copy(startPos);
                    checkPoint.add(direction.clone().multiplyScalar(stepSize * i));
                    
                    // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨éšœç¢ç‰©å†…
                    for (var j = 0; j < obstacles.length; j++) {
                        var obstacle = obstacles[j];
                        
                        // ç®€åŒ–æ£€æŸ¥ï¼šå¦‚æœç‚¹åœ¨éšœç¢ç‰©è¾¹ç•Œæ¡†å†…
                        var dx = Math.abs(checkPoint.x - obstacle.position.x);
                        var dz = Math.abs(checkPoint.z - obstacle.position.z);
                        var dy = Math.abs(checkPoint.y - obstacle.position.y);
                        
                        var halfWidth = (obstacle.width || 0) / 2;
                        var halfDepth = (obstacle.depth || 0) / 2;
                        var halfHeight = (obstacle.height || 0) / 2;
                        
                        // å¦‚æœç‚¹åœ¨éšœç¢ç‰©å†…éƒ¨
                        if (dx < halfWidth && dz < halfDepth && dy < halfHeight) {
                            return false; // è§†çº¿è¢«é˜»æŒ¡
                        }
                    }
                }
                
                return true; // è§†çº¿æœªè¢«é˜»æŒ¡
            }
            
            // é¿å¼€éšœç¢ç‰©
            function avoidObstacles(enemy, direction) {
                var avoidDirection = direction.clone();
                var avoidForce = 0;
                
                // æ£€æŸ¥é™„è¿‘çš„éšœç¢ç‰©
                for (var i = 0; i < obstacles.length; i++) {
                    var obstacle = obstacles[i];
                    var distance = enemy.position.distanceTo(obstacle.position);
                    var obstacleRadius = Math.max((obstacle.width || 0), (obstacle.depth || 0)) / 2;
                    
                    // å¦‚æœéšœç¢ç‰©åœ¨é¿è®©èŒƒå›´å†…
                    if (distance < obstacleRadius + 5) {
                        var awayFromObstacle = new THREE.Vector3();
                        awayFromObstacle.subVectors(enemy.position, obstacle.position);
                        awayFromObstacle.normalize();
                        
                        // è·ç¦»è¶Šè¿‘ï¼Œé¿è®©åŠ›åº¦è¶Šå¤§
                        var force = (obstacleRadius + 5 - distance) / (obstacleRadius + 5);
                        avoidDirection.add(awayFromObstacle.multiplyScalar(force));
                        avoidForce += force;
                    }
                }
                
                // å½’ä¸€åŒ–æ–¹å‘
                if (avoidForce > 0) {
                    avoidDirection.normalize();
                }
                
                return avoidDirection;
            }
            
            // æ•Œäººå°„å‡»
            function enemyShoot(enemy) {
                var directionToPlayer = new THREE.Vector3();
                directionToPlayer.subVectors(camera.position, enemy.position).normalize();
                
                // åˆ›å»ºæ•Œäººå­å¼¹
                var bulletGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                var bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                var bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                bullet.position.copy(enemy.position);
                bullet.position.y += 1;
                bullet.velocity = directionToPlayer.clone().multiplyScalar(30);
                bullet.damage = 10;
                
                scene.add(bullet);
                enemyBullets.push(bullet);
                
                // å­å¼¹å­˜æ´»æ—¶é—´
                setTimeout(function(bullet) {
                    if (bullet.parent) {
                        scene.remove(bullet);
                        var index = enemyBullets.indexOf(bullet);
                        if (index > -1) enemyBullets.splice(index, 1);
                    }
                }, 3000, bullet);
                
                playSound('enemyShoot');
            }
            
            // æ›´æ–°å­å¼¹ - æ”¹è¿›ç¢°æ’æ£€æµ‹
            function updateBullets(deltaTime) {
                // ç©å®¶å­å¼¹
                for (var i = bullets.length - 1; i >= 0; i--) {
                    var bullet = bullets[i];
                    bullet.position.add(bullet.velocity.clone().multiplyScalar(deltaTime));
                    
                    // æ£€æµ‹å­å¼¹ä¸æ•Œäººç¢°æ’
                    for (var j = enemies.length - 1; j >= 0; j--) {
                        var enemy = enemies[j];
                        if (enemy.health > 0 && bullet.position.distanceTo(enemy.position) < 1.5) {
                            // å‡»ä¸­æ•Œäºº
                            enemy.health -= bullet.damage;
                            
                            if (enemy.health <= 0) {
                                // æ•Œäººæ­»äº¡
                                gameState.score += 100;
                                gameState.enemiesAlive--;
                                updateUI();
                                
                                // æ­»äº¡æ•ˆæœ
                                enemy.material.color.setHex(0x333333);
                                setTimeout(function(enemy) {
                                    if (enemy.parent) {
                                        scene.remove(enemy);
                                        var index = enemies.indexOf(enemy);
                                        if (index > -1) enemies.splice(index, 1);
                                    }
                                }, 1000, enemy);
                                
                                playSound('enemyDeath');
                                
                                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ•Œäººéƒ½è¢«æ¶ˆç­
                                if (gameState.enemiesAlive <= 0) {
                                    gameWin();
                                }
                            } else {
                                playSound('hit');
                            }
                            
                            // ç§»é™¤å­å¼¹
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                    
                    // æ£€æµ‹å­å¼¹ä¸éšœç¢ç‰©ç¢°æ’
                    for (var j = 0; j < obstacles.length; j++) {
                        var obstacle = obstacles[j];
                        var dx = Math.abs(bullet.position.x - obstacle.position.x);
                        var dz = Math.abs(bullet.position.z - obstacle.position.z);
                        var dy = Math.abs(bullet.position.y - obstacle.position.y);
                        
                        var halfWidth = (obstacle.width || 0) / 2;
                        var halfDepth = (obstacle.depth || 0) / 2;
                        var halfHeight = (obstacle.height || 0) / 2;
                        
                        // å¦‚æœå­å¼¹åœ¨éšœç¢ç‰©å†…éƒ¨
                        if (dx < halfWidth && dz < halfDepth && dy < halfHeight) {
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // æ•Œäººå­å¼¹
                for (var i = enemyBullets.length - 1; i >= 0; i--) {
                    var bullet = enemyBullets[i];
                    bullet.position.add(bullet.velocity.clone().multiplyScalar(deltaTime));
                    
                    // æ£€æµ‹å­å¼¹ä¸ç©å®¶ç¢°æ’
                    if (bullet.position.distanceTo(camera.position) < 2) {
                        // å‡»ä¸­ç©å®¶
                        gameState.health -= bullet.damage;
                        updateUI();
                        
                        // ç§»é™¤å­å¼¹
                        scene.remove(bullet);
                        enemyBullets.splice(i, 1);
                        
                        playSound('playerHit');
                        
                        // æ£€æŸ¥ç©å®¶æ­»äº¡
                        if (gameState.health <= 0) {
                            gameOver();
                        }
                    }
                    
                    // æ£€æµ‹å­å¼¹ä¸éšœç¢ç‰©ç¢°æ’
                    for (var j = 0; j < obstacles.length; j++) {
                        var obstacle = obstacles[j];
                        var dx = Math.abs(bullet.position.x - obstacle.position.x);
                        var dz = Math.abs(bullet.position.z - obstacle.position.z);
                        var dy = Math.abs(bullet.position.y - obstacle.position.y);
                        
                        var halfWidth = (obstacle.width || 0) / 2;
                        var halfDepth = (obstacle.depth || 0) / 2;
                        var halfHeight = (obstacle.height || 0) / 2;
                        
                        // å¦‚æœå­å¼¹åœ¨éšœç¢ç‰©å†…éƒ¨
                        if (dx < halfWidth && dz < halfDepth && dy < halfHeight) {
                            scene.remove(bullet);
                            enemyBullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            // ç©å®¶ç§»åŠ¨ - æ”¹è¿›ç¢°æ’æ£€æµ‹
            function updatePlayer(deltaTime) {
                var moveX = 0, moveZ = 0;
                
                // é”®ç›˜æ§åˆ¶
                if (keys['w'] || keys['arrowup']) moveZ -= 1;
                if (keys['s'] || keys['arrowdown']) moveZ += 1;
                if (keys['a'] || keys['arrowleft']) moveX -= 1;
                if (keys['d'] || keys['arrowright']) moveX += 1;
                
                // è™šæ‹Ÿæ‘‡æ†æ§åˆ¶ï¼ˆç§»åŠ¨ç«¯ï¼‰
                if (joystick.active) {
                    moveX += joystick.x;
                    moveZ += joystick.y;
                }
                
                // å½’ä¸€åŒ–ç§»åŠ¨å‘é‡
                if (moveX !== 0 || moveZ !== 0) {
                    var length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    moveX /= length;
                    moveZ /= length;
                }
                
                // åº”ç”¨ç§»åŠ¨ï¼ˆåŸºäºç›¸æœºæ–¹å‘ï¼‰
                var forward = new THREE.Vector3(0, 0, -1);
                var right = new THREE.Vector3(1, 0, 0);
                
                forward.applyEuler(new THREE.Euler(0, player.yaw, 0));
                right.applyEuler(new THREE.Euler(0, player.yaw, 0));
                
                var moveDirection = new THREE.Vector3();
                moveDirection.add(forward.multiplyScalar(-moveZ));
                moveDirection.add(right.multiplyScalar(moveX));
                moveDirection.normalize();
                
                // åº”ç”¨é‡åŠ›
                player.velocity.y -= 9.8 * deltaTime;
                
                // ç§»åŠ¨ç©å®¶
                var moveSpeed = player.speed * deltaTime;
                var newPos = new THREE.Vector3();
                newPos.copy(camera.position);
                newPos.x += moveDirection.x * moveSpeed;
                newPos.z += moveDirection.z * moveSpeed;
                newPos.y += player.velocity.y * deltaTime;
                
                // æ£€æµ‹åœ°é¢ç¢°æ’
                if (newPos.y < player.height) {
                    newPos.y = player.height;
                    player.velocity.y = 0;
                    player.onGround = true;
                }
                
                // æ£€æµ‹ç©å®¶ä¸éšœç¢ç‰©ç¢°æ’
                var canMove = true;
                for (var i = 0; i < obstacles.length; i++) {
                    var obstacle = obstacles[i];
                    var dx = Math.abs(newPos.x - obstacle.position.x);
                    var dz = Math.abs(newPos.z - obstacle.position.z);
                    var dy = Math.abs(newPos.y - obstacle.position.y);
                    
                    var halfWidth = (obstacle.width || 0) / 2 + 1.5; // å¢åŠ ç¢°æ’åŠå¾„
                    var halfDepth = (obstacle.depth || 0) / 2 + 1.5;
                    var halfHeight = (obstacle.height || 0) / 2 + 1;
                    
                    // å¦‚æœç©å®¶åœ¨éšœç¢ç‰©å†…éƒ¨æˆ–å¤ªé è¿‘
                    if (dx < halfWidth && dz < halfDepth && dy < halfHeight) {
                        canMove = false;
                        
                        // å°è¯•å°†ç©å®¶æ¨å¼€
                        var pushDirection = new THREE.Vector3();
                        pushDirection.subVectors(camera.position, obstacle.position);
                        pushDirection.y = 0;
                        pushDirection.normalize();
                        
                        newPos.x = camera.position.x + pushDirection.x * 0.1;
                        newPos.z = camera.position.z + pushDirection.z * 0.1;
                        break;
                    }
                }
                
                if (canMove) {
                    camera.position.copy(newPos);
                }
                
                // é™åˆ¶ç©å®¶ç§»åŠ¨èŒƒå›´
                var maxDistance = 45;
                if (camera.position.x < -maxDistance) camera.position.x = -maxDistance;
                if (camera.position.x > maxDistance) camera.position.x = maxDistance;
                if (camera.position.z < -maxDistance) camera.position.z = -maxDistance;
                if (camera.position.z > maxDistance) camera.position.z = maxDistance;
            }
            
            // æ’­æ”¾éŸ³æ•ˆ
            function playSound(type) {
                // åˆ›å»ºç®€å•çš„éŸ³æ•ˆ
                try {
                    var audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    var oscillator = audioContext.createOscillator();
                    var gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // æ ¹æ®éŸ³æ•ˆç±»å‹è®¾ç½®å‚æ•°
                    switch(type) {
                        case 'shoot':
                            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                            break;
                        case 'hit':
                            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                            break;
                        case 'enemyDeath':
                            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                            break;
                        case 'playerHit':
                            oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);
                            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            break;
                        case 'reload':
                            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.3);
                            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            break;
                        case 'switch':
                            oscillator.frequency.setValueAtTime(500, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.1);
                            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                            break;
                        case 'enemyShoot':
                            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                            break;
                    }
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    // éŸ³æ•ˆAPIå¯èƒ½ä¸æ”¯æŒï¼Œé™é»˜å¤±è´¥
                }
            }
            
            // æ›´æ–°UI
            function updateUI() {
                // æ›´æ–°ç”Ÿå‘½å€¼
                var healthPercent = gameState.health / 100;
                document.getElementById('health-fill').style.width = (healthPercent * 100) + '%';
                
                // æ›´æ–°å…¶ä»–çŠ¶æ€
                document.getElementById('score-value').textContent = gameState.score;
                document.getElementById('enemies-value').textContent = gameState.enemiesAlive + '/' + gameState.enemiesTotal;
                document.getElementById('ammo-value').textContent = gameState.ammo + '/âˆ';
                
                // ç”Ÿå‘½å€¼é¢œè‰²å˜åŒ–
                var healthFill = document.getElementById('health-fill');
                if (gameState.health > 60) {
                    healthFill.style.background = 'linear-gradient(90deg, #00ff00, #ffff00)';
                } else if (gameState.health > 30) {
                    healthFill.style.background = 'linear-gradient(90deg, #ffff00, #ff9500)';
                } else {
                    healthFill.style.background = 'linear-gradient(90deg, #ff9500, #ff0000)';
                }
            }
            
            // æ¸¸æˆç»“æŸ
            function gameOver() {
                gameActive = false;
                document.getElementById('message-text').textContent = 'æ¸¸æˆç»“æŸ! åˆ†æ•°: ' + gameState.score;
                document.getElementById('message').style.display = 'block';
                exitPointerLock();
                playSound('playerHit');
            }
            
            // æ¸¸æˆèƒœåˆ©
            function gameWin() {
                gameActive = false;
                document.getElementById('message-text').textContent = 'èƒœåˆ©! ä½ æ¶ˆç­äº†æ‰€æœ‰æ•Œäºº! åˆ†æ•°: ' + gameState.score;
                document.getElementById('message').style.display = 'block';
                exitPointerLock();
                playSound('enemyDeath');
            }
            
            // é‡æ–°å¼€å§‹æ¸¸æˆ
            function restartGame() {
                // æ¸…é™¤åœºæ™¯
                while (scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
                
                // é‡ç½®æ¸¸æˆçŠ¶æ€
                enemies = [];
                bullets = [];
                enemyBullets = [];
                obstacles = [];
                
                gameState = {
                    score: 0,
                    health: 100,
                    ammo: 30,
                    maxAmmo: 30,
                    enemiesAlive: 10,
                    enemiesTotal: 10
                };
                
                currentWeapon = 'rifle';
                lastShot = 0;
                gameActive = true;
                
                // é‡ç½®ç©å®¶è§†è§’
                player.pitch = 0;
                player.yaw = 0;
                
                // éšè—æ¶ˆæ¯
                document.getElementById('message').style.display = 'none';
                
                // é‡æ–°åˆå§‹åŒ–åœºæ™¯
                initScene();
                updateUI();
                
                // æ›´æ–°æ­¦å™¨UI
                switchWeapon('rifle');
                
                // æ˜¾ç¤ºæŒ‡é’ˆé”å®šæç¤ºï¼ˆPCç«¯ï¼‰
                if (!isMobile) {
                    document.getElementById('pointer-lock-hint').style.display = 'block';
                }
            }
            
            // æ¸¸æˆå¾ªç¯
            function gameLoop() {
                var deltaTime = clock.getDelta();
                
                // æ›´æ–°ç©å®¶
                if (gameActive) {
                    updatePlayer(deltaTime);
                    
                    // æ›´æ–°æ•Œäºº
                    updateEnemies(deltaTime);
                    
                    // æ›´æ–°å­å¼¹
                    updateBullets(deltaTime);
                }
                
                // æ¸²æŸ“åœºæ™¯
                renderer.render(scene, camera);
                
                // è‡ªåŠ¨æ¢å¼¹ï¼ˆå¦‚æœå¼¹è¯ä¸º0ï¼‰
                if (gameActive && gameState.ammo <= 0) {
                    reloadWeapon();
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            // åˆå§‹åŒ–æ¸¸æˆ
            function startGame() {
                initScene();
                initEvents();
                updateUI();
                switchWeapon('rifle');
                gameLoop();
                
                // æ˜¾ç¤ºPCæç¤ºæˆ–ç§»åŠ¨æ§åˆ¶
                if (isMobile) {
                    document.getElementById('mobile-controls').style.display = 'flex';
                } else {
                    // æ˜¾ç¤ºæŒ‡é’ˆé”å®šæç¤º
                    document.getElementById('pointer-lock-hint').style.display = 'block';
                }
            }
            
            // å¼€å§‹æ¸¸æˆ
            startGame();
        }
    </script>
</body>
</html>
